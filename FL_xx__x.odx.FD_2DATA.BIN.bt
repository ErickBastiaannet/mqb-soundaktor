//------------------------------------------------
//--- 010 Editor v12.0 Binary Template
//
//      File: FL_xx__x.odx.FD_2DATA.BIN
//   Authors: Jille, Dark, Borg123
//   Version: 0.4
//   Purpose: Parse the contents of the MQB soundaktor firmware
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 0.1 - Initial version
//            0.2 - Additional field descriptions taken from MxCar sheet   
//            0.3.1 - 10 out of 12 tables mapped
//            0.3.2 - Gain table key     
//            0.4 - Parsed and visualized all the tables found at this moment 
//------------------------------------------------
// legend: 
// yellow/aqua = uncertain
// red         = unknown
// green       = confirmed
// gray        = seemingly irrelevant
// blue        = special
// purple      = potential checksum

ushort unknown_1 <bgcolor=cPurple >; //some kind of checksum? 
ubyte unknown_2 <bgcolor=cDkYellow>;
ubyte Gain_table_flag <bgcolor=cYellow>; // looks like a flag / counter for additional Gain tables
ushort unknown_3 <bgcolor=cLtBlue>; // doesn't change between versions. 
ushort unknown_4 <bgcolor=cLtBlue>; // doesn't change between versions. 
ushort unknown_5 <bgcolor=cLtBlue>; // doesn't change between versions. 
ushort unknown_6 <bgcolor=cLtBlue>; // doesn't change between versions. 
ushort unknown_7 <bgcolor=cLtBlue>; // doesn't change between versions. 
ushort unknown_8 <bgcolor=cSilver>; // doesn't change between versions. 
ushort unknown_9 <bgcolor=cSilver>; // doesn't change between versions. 
ushort unknown_10 <bgcolor=cSilver>; // doesn't change between versions. 
ushort unknown_11 <bgcolor=cSilver>; // doesn't change between versions. 
ushort unknown_12 <bgcolor=cSilver>; // doesn't change between versions. 
ushort unknown_13 <bgcolor=cLtBlue>; // doesn't change between versions. 
ushort unknown_14 <bgcolor=cLtBlue>; // doesn't change between versions. 
ushort unknown_15 <bgcolor=cLtBlue>; // doesn't change between versions. 
ushort unknown_16 <bgcolor=cLtBlue>; // doesn't change between versions. 
ushort unknown_17 <bgcolor=cLtBlue>; // doesn't change between versions. 
ushort unknown_18 <bgcolor=cDkYellow>; // identical to Amount_of_Defined_SignalFunctions_SF
ushort unknown_19 <bgcolor=cYellow>; 
ushort Damping_factor_for_something <bgcolor=cAqua>; // Range 0-65535 identical to Damping_factor_for_actuator_test

FSeek(62);
ushort source_filename_checksum <bgcolor=cBlack>;// CRC16-CCITT
char source_filename[64] <bgcolor=cDkGreen>;
ushort Amount_of_Defined_SoundProfiles_SP <bgcolor=cGreen>; 
ushort Amount_of_Defined_AmplitudeFunctions_AF <bgcolor=cDkGreen>;
ushort Amount_of_Defined_LoadFunctions_LF <bgcolor=cGreen>; 
ushort Amount_of_Defined_SpeedFunctions_GF <bgcolor=cDkGreen>;
ushort Amount_of_Defined_SignalFunctions_SF <bgcolor=cGreen>; 
ushort Selected_resolution_for_signal_table <bgcolor=cDkGreen>;

// 0: 512 Support points, max 32 Signals 
// 1: 1024 Support points, max 16 Signals  
// 2: 2048 Support points, max 8 Signals
// 3: 4096 Support points, max 4 Signals
// 4: 8192 Support points, max 2 Signals

short Damping_factor_for_actuator_test <bgcolor=cGreen>; // Range 0-65535
short Reserved_for_future_use <bgcolor=cGray>;

struct {
    ubyte Engine_code <bgcolor=cDkGreen>;
    char VIN_mask[17] <bgcolor=cGreen>;

    ubyte Charisma_01_Switch_Relapse_Clamp15 <bgcolor=cDkGreen>;   
    ubyte Charisma_02_Switch_Gearbox <bgcolor=cGreen>;
    
    ubyte Charisma_03_Default_driving_profile <bgcolor=cDkGreen>;
    ubyte Charisma_04_Reverse_driving_profile <bgcolor=cGreen>;

    ubyte Charisma_05_Comfort_driving_profile <bgcolor=cDkGreen>;
    ubyte Charisma_06_Normal_driving_profile <bgcolor=cGreen>;
    ubyte Charisma_07_Sport_driving_profile <bgcolor=cDkGreen>;
    ubyte Charisma_08_Offroad_driving_profile <bgcolor=cGreen>; 
    ubyte Charisma_09_Eco_driving_profile <bgcolor=cDkGreen>;
    ubyte Charisma_10_Race_driving_profile  <bgcolor=cGreen>;
    ubyte Charisma_11_GTE_driving_profile  <bgcolor=cDkGreen>;

    ubyte Reserved_for_future_use_1 <bgcolor=cGray>;  
    ubyte Reserved_for_future_use_2 <bgcolor=cGray>;  
    ubyte Reserved_for_future_use_3 <bgcolor=cGray>;  
} Car[Amount_of_Defined_SoundProfiles_SP];                                    

// Engine codes

// 07 - 0000 0111 - Kodiaq diesel Dxxx
// 0C - 0000 1100 - 2.0l CUNA diesel ?
// 14 - 0001 0100 - old-school A4 diesels 2.0l / 2.7l / 3.0l
// 29 - 0010 1001 - ??? A4 B9 diesel 
// 2A - 0010 1010 - ???
// 2B - 0010 1011 - 2.0l CJS / CJX
// 2D - 0010 1101 - A6 diesel ? 
// 42 - 0100 0010 - ???
// 45 - 0100 0101 - 2.0l CUPA diesel ?
// 48 - 0100 1000 - ??? A4 B9 diesel 
// 3F - 0011 1111 - ANY 

typedef struct {
    ushort value[8];
} sheet812[12];

typedef struct {
    ubyte value[8];
} sheet812b[12];

typedef struct {
    ushort value[8];
} sheet82[2];

// block of 96 short values 
sheet812 ST_Gain <bgcolor=cDkAqua>;

// block of 96 short values 
sheet812 ST_Phase <bgcolor=cDkYellow>;

// block of 96 short values 
sheet812 ST_Pitch_Shift <bgcolor=cDkAqua>;

// block of 96 short values 
sheet812 ST_Delay <bgcolor=cDkYellow>;

// block of 96 byte values 
// MX m-Gain probably, NEED TO VEFIRY
sheet812b MX_m_Gain <bgcolor=cDkAqua>; 

// block of 96 byte values 
sheet812b MX_n_Gain <bgcolor=cDkYellow>;

// block of 96 byte values 
// MX v-Gain probably, NEED TO VERIFY
sheet812b MX_v_Gain <bgcolor=cDkAqua>; 

if (Gain_table_flag > 0) {
    // block of 96 byte values 
    // this gain table appears only in newer firmware: 5F 0003+, 8S, 8W
    // but 5F 0001, 0002, 8K firmwares dont have it
    sheet812b Gain_4 <bgcolor=cDkYellow>; 
}

// block of 16 short values. 
sheet82 SUM_Gain_Clip <bgcolor=cDkGreen>;

// [06 30] address pointer from 01DATA file
ushort LIB_m_Gain_scale[32] <bgcolor=cGreen>; // values in [-0.3 - 0.98] range (5F 0003 fw) / [-0.4 - 1.00] range (565 AGA fw)

// [06 70] address pointer from 01DATA file 
ushort LIB_n_Gain_Revs_scale[256] <bgcolor=cDkGreen>; // values in [500 - 8150] (rpm) range quanified by 16256

// [08 70] address pointer from 01DATA file
ushort LIB_v_Gain_Speed_scale[32] <bgcolor=cGreen>; // values in [0 - 326.39] (km/h) range	

// [08 B0] address pointer from 01DATA file
struct {
    ushort value[32]; 
} LIB_m_Gain_data[8] <bgcolor=cDkGreen>;

// [0A B0] address pointer from 01DATA file
// could be LIB_n_Gain quantified by 16256
// number of non-empty columns should be stored in MISC data, varies greatly from fw to fw
struct { 
    ushort value[256]; 
} LIB_n_Gain_data[16] <bgcolor=cGreen> ; 

// [2A B0] address pointer from 01DATA file
// 8100h block size! 
struct {
    ushort value[32]; 
} LIB_v_Gain_data[4] <bgcolor=cDkGreen>;

short unknown_data[16384] <bgcolor=cDkAqua>; 

// Print a report to output 

local int i = 0;
local int j = 0;
local float x = 0;

Printf("%s \n", source_filename);
Printf("ID\tEngine\tVIN\t\tRelapseKl15\tGearbox\tDefault\tReverse\tComfort\tNormal\tSport\tOffroad\tEco\tRace\tGTE\tRFU1\tRFU2\tRFU3\t\n");

for( i = 0; i < Amount_of_Defined_SoundProfiles_SP; i++ ) {
    Printf("%i\t%02X\t%s\t%i\t%i\t%i\t%i\t%i\t%i\t%i\t%i\t%i\t%i\t%i\t%i\t%i\t%i\n", 
        i, 
        Car[i].Engine_code, 
        Car[i].VIN_mask, 
        Car[i].Charisma_01_Switch_Relapse_Clamp15, 
        Car[i].Charisma_02_Switch_Gearbox, 
        Car[i].Charisma_03_Default_driving_profile, 
        Car[i].Charisma_04_Reverse_driving_profile,
        Car[i].Charisma_05_Comfort_driving_profile,
        Car[i].Charisma_06_Normal_driving_profile,
        Car[i].Charisma_07_Sport_driving_profile,
        Car[i].Charisma_08_Offroad_driving_profile,
        Car[i].Charisma_09_Eco_driving_profile,
        Car[i].Charisma_10_Race_driving_profile,
        Car[i].Charisma_11_GTE_driving_profile,
        Car[i].Reserved_for_future_use_1,
        Car[i].Reserved_for_future_use_2,
        Car[i].Reserved_for_future_use_3
    );
} 					

void PrintHeader( char name[] ) {
    Printf("\n%s\n", name);
    Printf("BOOST\t\t\tHYBRID\t\t\tEFFICIENCY\n");
    Printf("Normal\tSport\tEco\tNormal\tSport\tEco\tNormal\tSport\n");
}


void PrintSheet12( char name[], struct sheet812 sheet) {
    PrintHeader( name + " USHORT" );
    for( i = 0; i < 12; i++ ) {
        for ( j = 0; j < 8; j++ ) {
            Printf("%i\t", sheet[i].value[j]);
        }
        Printf("\n");
    };			 
} 

void PrintSheet12_Q1( char name[], struct sheet812 sheet) {
    PrintHeader( name + " USHORT" );
    for( i = 0; i < 12; i++ ) {
        for ( j = 0; j < 8; j++ ) {
            Printf("%.3g\t", (float) sheet[i].value[j] / 0xFFFF );
        }
        Printf("\n");
    };			 
} 

void PrintSheet12_Q4( char name[], struct sheet812 sheet) {
    PrintHeader( name + " USHORT" );
    for( i = 0; i < 12; i++ ) {
        for ( j = 0; j < 8; j++ ) {
            Printf("%.3g\t", (float) sheet[i].value[j] / 4);
        }
        Printf("\n");
    };			 
} 

void PrintSheet12_Q16( char name[], struct sheet812 sheet) {
    PrintHeader( name + " USHORT" );
    for( i = 0; i < 12; i++ ) {
        for ( j = 0; j < 8; j++ ) {
            // there is definitelly a rounding issues exists
            // trying to compensate them
            x = (float) sheet[i].value[j] / 16;
            if (x > 44) { x++; }
            if (x > 178) { x++; }
            if (x > 358) { x++; }
            if (x > 538) { x++; }
            Printf("%iÂ°\t", x);
        }
        Printf("\n");
    };			 
} 

void PrintSheet12_Q45( char name[], struct sheet812 sheet) {
    PrintHeader( name + " USHORT" );
    for( i = 0; i < 12; i++ ) {
        for ( j = 0; j < 8; j++ ) {
            Printf("%.3g\t", (float) sheet[i].value[j] / 45);
        }
        Printf("\n");
    };			 
} 

void PrintSheet12_Q2Pi( char name[], struct sheet812 sheet) {
    PrintHeader( name + " USHORT" );
    for( i = 0; i < 12; i++ ) {
        for ( j = 0; j < 8; j++ ) {
             Printf("%.3g\t", (float) sheet[i].value[j] / 0xFFFF * 2 * 3.14159265359);
        }
        Printf("\n");
    };			 
} 


void PrintSheet12b( char name[], struct sheet812b sheet) {
    PrintHeader( name + " UBYTE" );
    for( i = 0; i < 12; i++ ) {
        for ( j = 0; j < 8; j++ ) {
            Printf("%i\t", sheet[i].value[j] + 1); // not sure do we need this +1
        }
        Printf("\n");
    };			 
} 

void PrintSheet2( char name[], struct sheet82 sheet) {
    PrintHeader( name + " USHORT" );
    for ( j = 0; j < 8; j++ ) {
        Printf("%.3g\t", (float) sheet[0].value[j] / 65536); // 0 < X < 1 // Q:65536
    }
    Printf("\n");
    // TODO: need to doublecheck this row of values, 
    // data parsed doesnt look like our example
    for ( j = 0; j < 8; j++ ) {
        Printf("%.3g\t", (float) sheet[1].value[j] / 8192); // 0 < X < 8 // Q:65536
    }
    Printf("\n");
} 

// SHORT spreadsheets 8x12
PrintSheet12_Q16("Spreadsheet 1: ST_Gain ???", ST_Gain);
PrintSheet12("Spreadsheet 2: ST_Phase ???", ST_Phase);
PrintSheet12_Q1("Spreadsheet 3: ST_Pitch_Shift", ST_Pitch_Shift);
PrintSheet12("Spreadsheet 4: ST Delay", ST_Delay);

// BYTE spreadsheets 8x12
PrintSheet12b("Spreadsheet 5: MX_m_Gain ???", MX_m_Gain);
PrintSheet12b("Spreadsheet 6: MX_n_Gain ???", MX_n_Gain);
PrintSheet12b("Spreadsheet 7: MX_v_Gain ???", MX_v_Gain);
if (Gain_table_flag > 0) {
    PrintSheet12b("Spreadsheet 8: Gain something ???", Gain_4);
}

// USHORT spreadsheet 8x2
PrintSheet2("Spreadsheet 9: SUM_Gain_Clip", SUM_Gain_Clip);


// Increase / Decrease revs scale ???
// could be useful for popcorn effect
Printf("\nSpreadsheet 10: LIB_m_Gain\nHEADER\tDATA\n");
for( i = 0; i < 32; i++ ) {
    Printf("%.2f", (float) LIB_m_Gain_scale[i] / 32768 - 1);
    for( j = 0; j < 8; j++ ) {
        Printf("\t%.4f", (float) LIB_m_Gain_data[j].value[i] / 65536);
    }
    Printf("\n");
}

Printf("\nSpreadsheet 11: LIB_n_Gain_Revs\nHEADER\tDATA\n");
for( i = 0; i < 256; i++ ) {
    Printf("%i", (float) LIB_n_Gain_Revs_scale[i] / 65536 * 16526);
    for( j = 0; j < 16; j++ ) {
        Printf("\t%.4f", (float) LIB_n_Gain_data[j].value[i] / 65536);
    }
    Printf("\n");
}

Printf("\nSpreadsheet 12: LIB_v_Gain_Speed\nHEADER\tDATA\n");
for( i = 0; i < 32; i++ ) {
    // real scale for this header column is the percentage [0 - 100%] from 326.39 value
    // multipliying it to 3.2639 shows absolute speed
    // (VW e-UP! is limited to 150kmh)
    Printf("%.2f", (float) LIB_v_Gain_Speed_scale[i] / 326.39 * 3.2639);
    for( j = 0; j < 4; j++ ) {
        Printf("\t%.4f", (float) LIB_v_Gain_data[j].value[i] / 65536);
    }
    Printf("\n");
}
